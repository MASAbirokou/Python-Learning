ジェネレータはfor文で利用できるイテラブルなオブジェクト。

リストやタプルが要素をメモリ上に保持するのと異なり、ジェネレータは次の要素が求められるたびに新たな要素を生成して返す（要素数にかかわらずメモリ使用量を小さくできる）。

# ジェネレータの例

値を無限に返し続けるジェネレータ`inf`を作成した例。

内部にある**yield式**がジェネレータの目印。

```python
def inf(n):
    while True:
        yield n
```

実行すると引数として渡した値を出力し続ける。

要素を無限に返すこのような動きは、全ての要素をメモリに保持するリストやタプルでは実現できない。

# ジェネレータの作り方

ジェネレータの作り方は次の２つ

- ジェネレータ関数
- ジェネレータ式

## 1.ジェネレーター関数（関数のように作成）

内部でyield式を使っている関数のことを**ジェネレータ関数**という。

ジェネレータ関数の戻り値はイテレータで、その特殊メソッド`_next_()`が呼ばれるたびに関数内の処理が次のyield式まで進む。

↓

呼び出し元に、yield式に渡した値を返すと、その時の状態を保持したままその行で処理を中断する。

↓

再度`_next_()`が呼ばれるとその行から処理が再開され関数を抜けると自動で「StopIteration」が送出される。

> イテレータ：イテラブルオブジェクトを使用した連続データのこと。
> 
> イテラブル：繰り返し可能なオブジェクトのこと。`for i in A`の`A`の部分に指定することができる。例えばlist,touple,rangeで生成したものはイテラブル。

```python
def gen_function(n):
    print('start')
    while n:
        print(f'yield: {n}')
        yield n  #ここで一時中断される
        n -= 1
```

この関数を以下のように実行できうる：

```
-----------------------------------------
gen = gen_function(2)
next(gen)  #組み込み関数next()に渡すと_next_()が呼ばれる
-----------------------------------------
#出力
start
yield: 2
2
-----------------------------------------
next(gen)
-----------------------------------------
#出力
yield: 1
1
-----------------------------------------
next(gen)
-----------------------------------------
#出力
StopIteration                      Traceback (most recent call last)
  in 
----> 1 next(gen)

StopIteration:
```

## 2.ジェネレータ式（内包表記を利用して作成）

リストやタプルなどのイテラブルなオブジェクトがあると、**内包表記を使ってそのイテラブルなオブジェクトからジェネレータを作る**ことができる。

そのようなジェネレータの作り方を**ジェネレータ式**といい、`（）`で囲む：

```python
x = [1, 2, 3, 4, 5]
gen = (i**2 for i in x)  #これがジェネレータ式
-----------------------------------------
next(gen)
-----------------------------------------
#出力
1
-----------------------------------------
gen[4]  #各要素は必要になるまで計算されない！
-----------------------------------------
#出力
TypeError                                 Traceback (most recent call last)
 in 
----> 1 gen[4]

TypeError: 'generator' object is not subscriptable
```

ジェネレータは必要になるまで計算されない。

だから、添字では呼ぶことができない（not subscriptable）。

# ジェネレータの注意点

## 組み込み関数`len()`が使えない！

**”ジェネレータは必要になるまで計算されない”** ということと関係してる。

```python
def gen(n):
    while n:
        yield n
        n -= 1
-----------------------------------------
len(gen(5))
-----------------------------------------
TypeError                                 Traceback (most recent call last)
 in 
----> 1 len(gen(5))
TypeError: object of type 'generator' has no len()
```

## ジェネレータを複数回利用する場合

**ジェネレータは“状態を保持する”** ということに注意。

以下のように、`list(g)`で`g`をリストとして展開しているから（つまりそのタイミングになるまで計算しない、のではなくリストとして一気に最後まで計算している）、
2回目以降の結果は常に０になる：

```g = gen(4)
-----------------------------------------
len(list(g))  #リストに展開（＝最後まで計算）
-----------------------------------------
#出力
4
-----------------------------------------
len(list(g))
-----------------------------------------
#出力
0
```









